/*
Package gorbac provides a lightweight role-based access
control implementation in Golang.

For the purposes of this package:

	* an identity has one or more roles.
	* a role requests access to a permission.
	* a permission is given to a role.

Thus, RBAC has the following model:

	* many to many relationship between identities and roles.
	* many to many relationship between roles and permissions.
	* roles can have parent roles.
*/
package gorbac

import (
	"sync"
)

const (
	bufferSize = 16
)

// AssertionFunc supplies more fine-grained permission controls.
type AssertionFunc func(string, string, *RBAC) bool

// Map exports RBAC to a structure data
type Map map[string]RoleMap

// RBAC object, in most cases it should be used as a singleton.
type RBAC struct {
	mutex   sync.RWMutex
	roles   map[string]Role
	factory RoleFactoryFunc
}

// NewWithFactory returns a RBAC structure with a specific factory function.
// Role structure will be generated by the function.
func NewWithFactory(factory RoleFactoryFunc) *RBAC {
	rbac := &RBAC{
		roles:   make(map[string]Role, bufferSize),
		factory: factory,
	}
	return rbac
}

// New returns a RBAC structure.
// The default role structure will be used.
func New() *RBAC {
	return NewWithFactory(NewBaseRole)
}

// RestoreWithFactory loads control data from a Map.
// User-defined type can be created by factory.
func RestoreWithFactory(data Map, factory RoleFactoryFunc) *RBAC {
	rbac := NewWithFactory(factory)
	for role, value := range data {
		rbac.Add(role, value[PermissionKey], value[ParentKey])
	}
	return rbac
}

// Restore loads control data from a Map, and the default Role will be used.
func Restore(data Map) *RBAC {
	return RestoreWithFactory(data, NewBaseRole)
}

// Set a role with `name`. It has `permissions` and `parents`.
// If the role is not existing, a new one will be created.
// This function will cover role's orignal permissions and parents.
func (rbac *RBAC) Set(name string, permissions []string, parents []string) {
	rbac.mutex.Lock()
	defer rbac.mutex.Unlock()
	role := rbac.getRole(name)
	role.Reset()
	for _, p := range permissions {
		role.AddPermission(p)
	}
	for _, pname := range parents {
		role.AddParent(pname)
	}
}

// Add a role with `name`. It has `permissions` and `parents`.
// If the role is not existing, a new one will be created.
// This function will add new permissions and parents to the role,
// and keep orignals.
func (rbac *RBAC) Add(name string, permissions []string, parents []string) {
	rbac.mutex.Lock()
	defer rbac.mutex.Unlock()
	role := rbac.getRole(name)
	for _, p := range permissions {
		role.AddPermission(p)
	}
	for _, pname := range parents {
		role.AddParent(pname)
	}
}

// Remove a role.
func (rbac *RBAC) Remove(name string) {
	rbac.mutex.Lock()
	defer rbac.mutex.Unlock()
	delete(rbac.roles, name)
}

// Internal getRole
func (rbac *RBAC) getRole(name string) Role {
	role, ok := rbac.roles[name]
	if !ok {
		role = rbac.factory(rbac, name)
		rbac.roles[name] = role
	}
	return role
}

// Get returns a role or nil if not exists.
func (rbac *RBAC) Get(name string) Role {
	rbac.mutex.RLock()
	defer rbac.mutex.RUnlock()
	role, ok := rbac.roles[name]
	if !ok {
		return nil
	}
	return role
}

// IsGranted tests if the `name` has `permission` in the `assert` condition.
func (rbac *RBAC) IsGranted(name, permission string,
	assert AssertionFunc) bool {
	rbac.mutex.RLock()
	defer rbac.mutex.RUnlock()
	if assert != nil && !assert(name, permission, rbac) {
		return false
	}
	if role, ok := rbac.roles[name]; ok {
		return role.HasPermission(permission)
	}
	return false
}

// Dump RBAC
func (rbac *RBAC) Dump() Map {
	m := make(Map)
	for _, role := range rbac.roles {
		roleMap := RoleToMap(role)
		m[role.Name()] = roleMap
	}
	return m
}
